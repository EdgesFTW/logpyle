<html>
  <head>
    <title>web-interface</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
    <script defer src="https://pyscript.net/latest/pyscript.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.min.js"></script>
<style>
.constantsDiv {
	max-height: 150px;
	width: fit-content;
	overflow: auto;
	margin-top: 20px;
	padding: 5px;
	padding-top: 0px;
	max-width: 100%;
}
.constantsTable {
	border: 1px solid;
	width: fit-content;
}
.constantsTable thead th{
	position: sticky;
	top: 0px;
	background-color: #E0E0E0;
}
.constantsTr {
	border: 1px solid;
}
.constantsTd {
	border: 1px solid;
	white-space: nowrap;
	text-align: left;
}
.quantitiesDiv {
	max-height: 150px;
	width: fit-content;
	overflow: auto;
	margin-top: 20px;
	padding: 5px;
	padding-top: 0px;
}
.quantitiesTable {
	border: 1px solid;
	width: fit-content;
}
.quantitiesTable thead th{
	position: sticky;
	top: 0px;
	background-color: #E0E0E0;
}
.quantitiesTr {
	border: 1px solid;
}
.quantitiesTd {
	border: 1px solid;
}

.radioDiv {
	display:flex;
	flex-direction:row;
}


</style>
  </head>
  <body>

<script>
// expect to be called from python
async function chartsOutputGraph(id, x, ys, colors) {
	id = JSON.parse(id);
	x = JSON.parse(x);
	ys = JSON.parse(ys);

	// resize canvas before drawing to it
	let canvas = document.getElementById("chart" + id);
	canvas.style.width='100%';
	canvas.style.height='100%';
	canvas.width  = canvas.offsetWidth;
	canvas.height = canvas.offsetHeight;

	let datasets = [];
	let scales = {};
	// add ys to dataset
	for (const [key, value] of Object.entries(ys)) {
		// colors = ys["colors"]
		// y_vals = ys["vals"]
		datasets.push({
			data: value["vals"],
			label: key + " (" + value["units"] + ")",
			borderColor: value["color"],
			// yAxisID: key,
		});
		// scales[key] = {
		// 	type: "linear",
		// 	display: true,
		// 	grid: {
		// 		drawOnChartArea: false, // only want the grid lines for one axis to show up
		// 	},

		// }
	}

	// create chart pointing to the file's chart canvas
	new Chart(document.getElementById("chart"+id), {
		type: 'line',
		data: {
			labels: x,
			datasets: datasets
		},

		options: {
			responsive: true,
			plugins: {
				legend: {
					position: 'top',
				},
				title: {
					display: true,
					text: 'Chart.js Line Chart'
				}
			}
		},

	});



}


async function download(filename, contents) {
  var element = document.createElement('a');
  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(contents));
  element.setAttribute('download', filename);

  element.style.display = 'none';
  document.body.appendChild(element);

  element.click();

  document.body.removeChild(element);
}




</script>

    <py-config>
      packages = [
	  "matplotlib",
	  "pandas",
	  "sqlite3",
	  "pytools",
	  ]
    </py-config>

<py-script>
import code

try:
	import readline
	import rlcompleter  # noqa: F401
	HAVE_READLINE = True
except ImportError:
	HAVE_READLINE = False


import logging

logger = logging.getLogger(__name__)

from dataclasses import dataclass
from itertools import product
from sqlite3 import Connection, Cursor
from typing import (Any, Callable, Dict, Generator, List, Optional, Sequence,
					Set, Tuple, Type, Union)

from pytools import Table


@dataclass(frozen=True)
class PlotStyle:
	dashes: Tuple[int, ...]
	color: str


PLOT_STYLES = [
		PlotStyle(dashes=dashes, color=color)
		for dashes, color in product(
			[(), (12, 2), (4, 2),  (2, 2), (2, 8)],
			["blue", "green", "red", "magenta", "cyan"],
			)]


class RunDB:
	def __init__(self, db: Connection, interactive: bool) -> None:
		self.db = db
		self.interactive = interactive
		self.rank_agg_tables: Set[Tuple[str, Callable[..., Any]]] = set()

	def q(self, qry: str, *extra_args: Any) -> Cursor:
		return self.db.execute(self.mangle_sql(qry), extra_args)

	def mangle_sql(self, qry: str) -> str:
		return qry

	def get_rank_agg_table(self, qty: str,
							rank_aggregator: Callable[..., Any]) -> str:
		tbl_name = f"rankagg_{rank_aggregator}_{qty}"

		if (qty, rank_aggregator) in self.rank_agg_tables:
			return tbl_name

		logger.info("Building temporary rank aggregation table {tbl_name}.")

		self.db.execute("create temporary table %s as "
				"select run_id, step, %s(value) as value "
				"from %s group by run_id,step" % (
					tbl_name, rank_aggregator, qty))
		self.db.execute("create index %s_run_step on %s (run_id,step)"
				% (tbl_name, tbl_name))
		self.rank_agg_tables.add((qty, rank_aggregator))
		return tbl_name

	def scatter_cursor(self, cursor: Cursor, labels: Optional[List[str]] = None,
						*args: Any, **kwargs: Any) -> None:
		import matplotlib.pyplot as plt

		data_args = tuple(zip(*list(cursor)))
		plt.scatter(*(data_args + args), **kwargs)

		if isinstance(labels, list) and len(labels) == 2:
			plt.xlabel(labels[0])
			plt.ylabel(labels[1])
		elif labels is not None:
			raise TypeError("The 'labels' parameter must be a list with two"
							"elements.")

		if self.interactive:
			plt.show()

	def plot_cursor(self, cursor: Cursor, labels: Optional[List[str]] = None,
					*args: Any, **kwargs: Any) -> None:
		import matplotlib.pyplot as plt
		from matplotlib.pyplot import legend, plot, show, savefig

		fig, _ = plt.subplots()

		auto_style = kwargs.pop("auto_style", True)

		if len(cursor.description) == 2:
			if auto_style:
				style = PLOT_STYLES[0]
				kwargs["dashes"] = style.dashes
				kwargs["color"] = style.color

			x, y = list(zip(*list(cursor)))
			p = plot(x, y, *args, **kwargs)

			if isinstance(labels, list) and len(labels) == 2:
				p[0].axes.set_xlabel(labels[0])
				p[0].axes.set_ylabel(labels[1])
			elif labels is not None:
				raise TypeError("The 'labels' parameter must be a list with two"
								" elements.")

		elif len(cursor.description) > 2:
			small_legend = kwargs.pop("small_legend", True)

			def format_label(kv_pairs: Sequence[Tuple[str, Any]]) -> str:
				return " ".join(f"{column}:{value}"
							for column, value in kv_pairs)
			format_label = kwargs.pop("format_label", format_label)

			def do_plot(x: List[float], y: List[float],
						row_rest: Tuple[Any, ...]) -> None:
				my_kwargs = kwargs.copy()
				style = PLOT_STYLES[style_idx[0] % len(PLOT_STYLES)]
				if auto_style:
					my_kwargs.setdefault("dashes", style.dashes)
					my_kwargs.setdefault("color", style.color)

				my_kwargs.setdefault("label",
						format_label(list(zip(
							(col[0] for col in cursor.description[2:]),
							row_rest))))

				plot(x, y, *args, hold=True, **my_kwargs)
				style_idx[0] += 1

			style_idx = [0]
			for x, y, rest in split_cursor(cursor):
				do_plot(x, y, rest)  # type: ignore[arg-type]

		else:
			raise ValueError("invalid number of columns")

		if self.interactive:
			from pyodide.ffi import to_js
			from js import document, console, window
			from os.path import exists
			import matplotlib.image as mpimg
			display(fig, target="graph-area", append=False)
			show()

	def print_cursor(self, cursor: Cursor) -> None:
		print(table_from_cursor(cursor))


def split_cursor(cursor: Cursor) -> Generator[
		Tuple[List[Any], List[Any], Optional[Tuple[Any, ...]]], None, None]:

	x: List[Any] = []
	y: List[Any] = []
	last_rest = None
	for row in cursor:
		row_tuple = tuple(row)
		row_rest = row_tuple[2:]

		if last_rest is None:
			last_rest = row_rest

		if row_rest != last_rest:
			yield x, y, last_rest
			del x[:]
			del y[:]

			last_rest = row_rest

		x.append(row_tuple[0])
		y.append(row_tuple[1])
	if x:
		yield x, y, last_rest


def table_from_cursor(cursor: Cursor) -> Table:
	tbl = Table()
	tbl.add_row(tuple([column[0] for column in cursor.description]))
	for row in cursor:
		tbl.add_row(row)
	return tbl


class MagicRunDB(RunDB):
	def mangle_sql(self, qry: str) -> str:
		up_qry = qry.upper()
		if "FROM" in up_qry and "$$" not in up_qry:
			return qry

		magic_columns = set()
		import re

		# should be: re.Match[Any]
		def replace_magic_column(match: Any) -> str:
			qty_name = match.group(1)
			rank_aggregator = match.group(2)

			if rank_aggregator is not None:
				rank_aggregator = rank_aggregator[1:]
				magic_columns.add((qty_name, rank_aggregator))
				return f"{rank_aggregator}_{qty_name}.value AS {qty_name}"
			else:
				magic_columns.add((qty_name, None))
				return "%s.value AS %s" % (qty_name, qty_name)

		magic_column_re = re.compile(r"\$([a-zA-Z][A-Za-z0-9_]*)(\.[a-z]*)?")
		qry, _ = magic_column_re.subn(replace_magic_column, qry)

		other_clauses = [  # noqa: F841
				"UNION",  "INTERSECT", "EXCEPT", "WHERE", "GROUP",
				"HAVING", "ORDER", "LIMIT", ";"]

		from_clause = "from runs "
		last_tbl = None
		for tbl, rank_aggregator in magic_columns:
			if rank_aggregator is not None:
				full_tbl = f"{rank_aggregator}_{tbl}"
				full_tbl_src = "{} as {}".format(
						self.get_rank_agg_table(tbl, rank_aggregator),
						full_tbl)

				if last_tbl is not None:
					addendum = f" and {last_tbl}.step = {full_tbl}.step"
				else:
					addendum = ""
			else:
				full_tbl = tbl
				full_tbl_src = tbl

				if last_tbl is not None:
					addendum = " and {}.step = {}.step and {}.rank={}.rank".format(
							last_tbl, full_tbl, last_tbl, full_tbl)
				else:
					addendum = ""

			from_clause += " inner join {} on ({}.run_id = runs.id{}) ".format(
					full_tbl_src, full_tbl, addendum)
			last_tbl = full_tbl

		def get_clause_indices(qry: str) -> Dict[str, int]:
			other_clauses = ["UNION",  "INTERSECT", "EXCEPT", "WHERE", "GROUP",
					"HAVING", "ORDER", "LIMIT", ";"]

			result = {}
			up_qry = qry.upper()
			for clause in other_clauses:
				clause_match = re.search(r"\b%s\b" % clause, up_qry)
				if clause_match is not None:
					result[clause] = clause_match.start()

			return result

		# add 'from'
		if "$$" in qry:
			qry = qry.replace("$$", " %s " % from_clause)
		else:
			clause_indices = get_clause_indices(qry)

			if not clause_indices:
				qry = qry+" "+from_clause
			else:
				first_clause_idx = min(clause_indices.values())
				qry = (
						qry[:first_clause_idx]
						+ from_clause
						+ qry[first_clause_idx:])

		return qry


def make_runalyzer_symbols(db: RunDB) \
		-> Dict[str, Union[RunDB, str, None, Callable[..., Any]]]:
	return {
			"__name__": "__console__",
			"__doc__": None,
			"db": db,
			"mangle_sql": db.mangle_sql,
			"q": db.q,
			"dbplot": db.plot_cursor,
			"dbscatter": db.scatter_cursor,
			"dbprint": db.print_cursor,
			"split_cursor": split_cursor,
			"table_from_cursor": table_from_cursor,
			}


class RunalyzerConsole(code.InteractiveConsole):
	def __init__(self, db: RunDB) -> None:
		self.db = db
		code.InteractiveConsole.__init__(self,
				make_runalyzer_symbols(db))

		try:
			import numpy  # noqa: F401
			self.runsource("from numpy import *")
		except ImportError:
			pass

		try:
			import matplotlib.pyplot  # noqa
			self.runsource("from matplotlib.pyplot import *")
		except ImportError:
			pass
		except RuntimeError:
			pass

		if HAVE_READLINE:
			import atexit
			import os

			histfile = os.path.join(os.environ["HOME"], ".runalyzerhist")
			if os.access(histfile, os.R_OK):
				readline.read_history_file(histfile)
			atexit.register(readline.write_history_file, histfile)
			readline.parse_and_bind("tab: complete")

		self.last_push_result = False

	def push(self, cmdline: str) -> bool:
		if cmdline.startswith("."):
			try:
				self.execute_magic(cmdline)
			except Exception:
				import traceback
				traceback.print_exc()
		else:
			self.last_push_result = code.InteractiveConsole.push(self, cmdline)

		return self.last_push_result

	def execute_magic(self, cmdline: str) -> None:
		cmd_end = cmdline.find(" ")
		if cmd_end == -1:
			cmd = cmdline[1:]
			args = ""
		else:
			cmd = cmdline[1:cmd_end]
			args = cmdline[cmd_end+1:]

		if cmd == "help":
			print("""
Commands:
	.help        show this help message
	.q SQL       execute a (potentially mangled) query
	.constants   show a list of (constant) run properties
	.quantities  show a list of time-dependent quantities
	.warnings    show a list of warnings
	.logging     show a list of logging messages

Plotting:
	.plot SQL    plot results of (potentially mangled) query.
				result sets can be (x,y) or (x,y,descr1,descr2,...),
				in which case a new plot will be started for each
				tuple (descr1, descr2, ...)
	.scatter SQL make scatterplot results of (potentially mangled) query.
				result sets can have between two and four columns
				for (x,y,size,color).

SQL mangling, if requested ("MagicSQL"):
	select $quantity where pred(feature)

Custom SQLite aggregates:
	stddev, var, norm1, norm2

Available Python symbols:
	db: the SQLite database
	mangle_sql(query_str): mangle the SQL query string query_str
	q(query_str): get db cursor for mangled query_str
	dbplot(cursor): plot result of cursor
	dbscatter(cursor): make scatterplot result of cursor
	dbprint(cursor): print result of cursor
	split_cursor(cursor): x,y,data gather that .plot uses internally
	table_from_cursor(cursor): Create a printable table from a cursor
""")
		elif cmd == "q":
			self.db.print_cursor(self.db.q(args))

		elif cmd == "runprops" or cmd == "constants":
			cursor = self.db.db.execute("select * from runs")
			columns = [column[0] for column in cursor.description]
			columns.sort()
			for col in columns:
				print(col)
		elif cmd == "quantities":
			self.db.print_cursor(self.db.q("select * from quantities order by name"))
		elif cmd == "warnings":
			self.db.print_cursor(self.db.q("select * from warnings"))
		elif cmd == "logging":
			self.db.print_cursor(self.db.q("select * from logging"))
		elif cmd == "title":
			from pylab import title
			title(args)
		elif cmd == "plot":
			cursor = self.db.db.execute(self.db.mangle_sql(args))
			columnnames = [column[0] for column in cursor.description]
			self.db.plot_cursor(cursor, labels=columnnames)
		elif cmd == "scatter":
			cursor = self.db.db.execute(self.db.mangle_sql(args))
			columnnames = [column[0] for column in cursor.description]
			self.db.scatter_cursor(cursor, labels=columnnames)
		else:
			print("invalid magic command")



from pytools import VarianceAggregator  # noqa: E402


class Variance(VarianceAggregator):
	def __init__(self) -> None:
		VarianceAggregator.__init__(self,  # type: ignore[no-untyped-call]
									entire_pop=True)


class StdDeviation(Variance):
	def finalize(self) -> Optional[float]:
		result = Variance.finalize(self)  # type: ignore[no-untyped-call]

		if result is None:
			return None
		else:
			from math import sqrt
			return sqrt(result)


class Norm1:
	def __init__(self) -> None:
		self.abs_sum = 0.0

	def step(self, value: float) -> None:
		self.abs_sum += abs(value)

	def finalize(self) -> float:
		return self.abs_sum


class Norm2:
	def __init__(self) -> None:
		self.square_sum = 0.0

	def step(self, value: float) -> None:
		self.square_sum += value**2

	def finalize(self) -> float:
		from math import sqrt
		return sqrt(self.square_sum)


def my_sprintf(format: str, arg: str) -> str:
	return format % arg




def make_wrapped_db(filename: str, interactive: bool, mangle: bool) -> RunDB:
	import sqlite3
	db = sqlite3.connect(filename)
	db.create_aggregate("stddev", 1, StdDeviation)  # type: ignore[arg-type]
	db.create_aggregate("var", 1, Variance)
	db.create_aggregate("norm1", 1, Norm1)  # type: ignore[arg-type]
	db.create_aggregate("norm2", 1, Norm2)  # type: ignore[arg-type]

	db.create_function("sprintf", 2, my_sprintf)
	from math import pow, sqrt
	db.create_function("sqrt", 1, sqrt)
	db.create_function("pow", 2, pow)

	if mangle:
		db_wrap_class: Type[RunDB] = MagicRunDB
	else:
		db_wrap_class = RunDB

	return db_wrap_class(db, interactive=interactive)



</py-script>

<py-script>
import asyncio
import json
import js
from js import document, DOMParser
from pyscript import Element
from pyodide.ffi import create_proxy
import os
import sqlite3
import micropip

async def customImports():
    pass

class dataFile:
    def __init__(self, name):
        self.name = name
        self.constants = {}
        self.quantities = {}


nextId = 1

# this HTML string was imported from newFile.html
fileDiv = """
<div class="newFile" id="{0}" style="display:flex;flex-direction:column">
	<div class="inputFileDiv">
		<label for="file{0}">Choose a Logpyle sqlite file to analyze:</label>
		<br>
		<input id="file{0}" name="file{0}" type="file" style="margin:5px;padding=5px;">
	</div>

    <div class="constantsDiv " id="constants{0}">
		<table class="constantsTable" id="constantsTable{0}">
			<thead>
				<tr class="constantsTr">
					<th class="constantsTd">Constant</th>
					<th class="constantsTd">Value</th>
				</tr>
			</thead>
			<tbody>
			</tbody>
        </table>
    </div>
    <div class="quantitiesDiv " id="quantities{0}">
		<table class="quantitiesTable" id="quantitiesTable{0}">
			<thead>
				<tr class="quantitiesTr">
					<th class="quantitiesTr">Quantity</th>
					<th class="quantitiesTr">Units</th>
					<th class="quantitiesTr">Description</th>
					<th class="quantitiesTr">ID</th>
					<th class="quantitiesTr">Aggregation Rank</th>
				</tr>
			</thead>
			<tbody>
			</tbody>
        </table>
    </div>
    <div id="interactive{0}" style="display:flex;flex-direction:row">
        <div id="menu{0}" style="display:flex;flex-direction:column">
            <div id="plot{0}" style="display:flex;flex-direction:column;margin:5px;padding=5px;background-color:#C0C0C0">
				<button id="plotButton{0}" style="height:30px;padding:5px" param="{0}">
                    Create Plot (Runalyzer)
                </button>
				<button id="chartsButton{0}" style="height:30px;padding:5px" param="{0}">
                    Create Chart
                </button>

				<div>
					<label for="quantity1{0}">X-axis Quantity:</label>
					<div id="xQuantity{0}" style="display:flex;flex-direction:column;margin:5px;padding=5px;">
						<select name="quantity1_{0}" id="quantity1_{0}">
						</select>
					</div>
				</div>

				<div>
					<label for="quantity2{0}">Y-axis Quantities:</label>
					<div id="yQuantities{0}" style="display:flex;flex-direction:column;margin:5px;padding=5px;">
						<div style="white-space:nowrap">
							<select name="quantity2{0}" id="quantity2_{0}" name="q2">
							</select>
							<input type="color">
						</div>
					</div>
				</div>
				<button id="addLineButton{0}" style="height:30px;margin:5px;padding:5px" param1="{0}">
					Add Line to Plot
				</button>
            </div>

            <div id="table{0}" style="display:flex;flex-direction:column;margin:5px;padding:5px;background-color:#C0C0C0">
				<div id="tableHeader{0}" style="white-space:nowrap">

					<label for="tableQuantitySelect{0}">Table Quantity:</label>
					<select name="tableQuantitySelect{0}" id="tableQuantitySelect{0}">
					</select>

					<button id="tableButton{0}" style="height:30px;padding:5px;width:fit-content;" param="{0}">
						Add to list
					</button>

				</div>
				<ol id="tableList{0}" style="margin-top:0px">

				</ol>
				<div id="tableFooter{0}" style="display:flex;flex-direction:row">
					<button id="tableDownloadButton{0}" style="height:30px;padding:5px" param="{0}">
						Download Table
					</button>
					<button id="tablePrintButton{0}" style="height:30px;padding:5px;width:fit-content;" param="{0}">
						Print Table
					</button>

				</div>
            </div>
        </div>
        <div id="output{0}" style="margin:5px;"></div>
		<div style="flex-basis:100%">
			<canvas id="chart{0}"></canvas>
		</div>
    </div>
</div>


"""


def addFileFunc():
    global nextId

    fileList = document.getElementById("fileList")
    parser = DOMParser.new()
    html = parser.parseFromString(fileDiv.format(str(nextId)), 'text/html')
    fileList.appendChild(html.body)

    newFile = document.getElementById(str(nextId))
    if nextId % 2 == 0:
        # grey minus some green
        newFile.style.backgroundColor = "#B0A8B0"
    else:
        # grey minus some blue
        newFile.style.backgroundColor = "#B0B0A8"

    # attach listener to new file input
    input = document.getElementById("file" + str(nextId))
    input.addEventListener("change", create_proxy(storeFile))

    nextId = nextId + 1


async def runPlot(event):
    # TODO loop over all y-axis quantities and create multiple lines
    id = event.target.getAttribute("param")
    output = document.getElementById("output" + str(id))
    output.id = "graph-area"
    runDb = make_wrapped_db(file_dict[id].name, True, True)
    q1 = document.getElementById("quantity1_" + str(id)).value
    q2 = document.getElementById("quantity2_" + str(id)).value
    query = "select ${}, ${}".format(q1, q2)
    cursor = runDb.db.execute(runDb.mangle_sql(query))
    columnnames = [column[0] for column in cursor.description]
    runDb.plot_cursor(cursor, labels=columnnames)

    output.id = "output" + str(id)

async def runChart(event):
    id = event.target.getAttribute("param")
    x_quantity: str = document.getElementById("quantity1_" + str(id)).value
    x = file_dict[id].quantities[x_quantity]
    x_vals = x["vals"]
    x_vals = [ ele[0] for ele in x_vals]
    # x_vals = [1,2]

    y_vals = {}
    y_quantities_div = document.getElementById("yQuantities" + str(id))
    for y_quantity_div in y_quantities_div.children:
        y_values_elements = y_quantity_div.children
        y_name = y_values_elements[0].value
        color = y_values_elements[1].value

        y_ele = file_dict[id].quantities[y_name]

        y_val = y_ele["vals"]
        y_val = [ ele[0] for ele in y_val]

        units = y_ele["units"]

        y_vals[y_name] = {}
        y_vals[y_name]['vals'] = y_val
        y_vals[y_name]['color'] = color
        y_vals[y_name]['units'] = units


    # y_vals = {"lol": [0.005,0.015], "lol2": [0.002,0.007]}
    js.chartsOutputGraph(
            id,
            json.dumps(x_vals),
            json.dumps(y_vals),
            )

        # file_dict[id].quantities[q_name] = {'vals':vals, 'id': q_id,
        #                                     'units':q_unit, 'desc':q_desc,
        #                                     'rank_agg': q_rank_agg}


async def addTableList(event):
    id = event.target.getAttribute("param")
    quantity = document.getElementById("tableQuantitySelect" + str(id)).value
    table_list = document.getElementById("tableList" + str(id))
    item = document.createElement("li")
    text = document.createElement("span")
    text.innerHTML = str(quantity)
    item.setAttribute("val", str(quantity))
    item.style = "margin:2px;"
    del_button = document.createElement("button")
    del_button.style.float = "right"
    del_button.innerHTML = "delete"
    del_button.addEventListener("click", create_proxy(removeTableEle))
    item.appendChild(text)
    item.appendChild(del_button)
    table_list.appendChild(item)


async def addLine(event):
    id = event.target.getAttribute("param1")
    i = event.target.param2
    event.target.param2 = event.target.param2 + 1
    y_quantities = document.getElementById("yQuantities" + str(id))

    y_div = document.createElement("div")
    y_select = document.createElement("select")
    y_color = document.createElement("input")

    y_div.setAttribute("style", "white-space:nowrap")
    y_color.setAttribute("type", "color")


    for quantity in file_dict[id].quantities:
        item = document.createElement("option")
        item.innerHTML = quantity
        item.value = quantity
        y_select.appendChild(item)

    y_div.appendChild(y_select)
    y_div.appendChild(y_color)

    y_quantities.appendChild(y_div)

async def removeTableEle(event):
    event.target.parentElement.remove()


async def runTable(event):
    import matplotlib.pyplot as plt
    id = event.target.getAttribute("param")
    output = document.getElementById("output" + str(id))
    output.id = "graph-area"
    runDb = make_wrapped_db(file_dict[id].name, True, True)
    query = "select $t_sim, $t_2step"
    cursor = runDb.db.execute(runDb.mangle_sql(query))
    columnnames = [column[0] for column in cursor.description]
    runDb.plot_cursor(cursor, labels=columnnames)

    output.id = "output" + str(id)


def downloadTable(event):
    id = event.target.getAttribute("param")

    names = []
    table_list = document.getElementById("tableList" + str(id))
    for li in table_list.children:
        names.append(li.children[0].innerHTML)

    quantities = {}
    for name in names:
        vals = file_dict[id].quantities[name]["vals"]
        vals  = [ ele[0] for ele in vals ]
        quantities[name] = vals




    title = "# " + " vs. ".join(quantities.keys())

    body = ""
    items = list(quantities.values())
    for line_num in range(len(items[0])):
        cur_vals = [ str(ele[line_num]) for ele in items]
        line = "\t".join(cur_vals) + "\n"
        body += line

    js.download("output.txt", title + "\n" + body)

    pass


def printTable(event):
    pass



async def storeFile(event):
    global file_dict
    fileList = event.target.files.to_py()
    from js import document, Uint8Array
    id = event.target.parentElement.parentElement.id

    # write database file
    for f1 in fileList:
        with open(f1.name, 'wb') as file:
            data = Uint8Array.new(await f1.arrayBuffer())
            file.write(bytearray(data))

    for f1 in fileList:
        file_dict[id] = dataFile(f1.name)

    # extract constants from sqlite file
    runDb = make_wrapped_db(file_dict[id].name, True, True)
    cursor = runDb.db.execute("select * from runs")
    columns = [col[0] for col in cursor.description]
    vals = list([row for row in cursor][0])
    for (col, val) in zip(columns, vals):
        file_dict[id].constants[col] = val

    # extract quantities from sqlite file
    cursor = runDb.db.execute("select * from quantities order by name")
    columns = [col[0] for col in cursor.description]
    for row in cursor:
        q_id, q_name, q_unit, q_desc, q_rank_agg = row
        tmp_cur = runDb.db.execute(runDb.mangle_sql(
            "select ${}".format(q_name)))

        vals = [val for val in tmp_cur]
        file_dict[id].quantities[q_name] = {'vals':vals, 'id': q_id,
                                            'units':q_unit, 'desc':q_desc,
                                            'rank_agg': q_rank_agg}

    # display constants
    constantsTable = document.getElementById("constantsTable" + str(id))
    for key, value in file_dict[id].constants.items():
        # item = document.createElement("li")
        # item.innerHTML = str(k) + ": " + str(v)
        # constants_list.appendChild(item)

        row = document.createElement('tr')
        row.className = "constantsTr"

        quantity_ele = document.createElement('td')
        quantity_ele.className = "constantsTd"
        quantity_ele.innerHTML = key
        row.appendChild(quantity_ele)

        units_ele = document.createElement('td')
        units_ele.className = "constantsTd"
        units_ele.innerHTML = value
        row.appendChild(units_ele)

        # append the row to the body of the table
        constantsTable.children[1].appendChild(row)

    # display quantities
    quantitiesTable = document.getElementById("quantitiesTable" + str(id))
    for q_name, quantity in file_dict[id].quantities.items():
        row = document.createElement('tr')
        row.className = "quantitiesTr"

        quantity_ele = document.createElement('td')
        quantity_ele.className = "quantitiesTd"
        quantity_ele.innerHTML = q_name
        row.appendChild(quantity_ele)

        units_ele = document.createElement('td')
        units_ele.className = "quantitiesTd"
        units_ele.innerHTML = quantity['units']
        row.appendChild(units_ele)

        desc_ele = document.createElement('td')
        desc_ele .className = "quantitiesTd"
        desc_ele.innerHTML = quantity['desc']
        row.appendChild(desc_ele)

        id_ele = document.createElement('td')
        id_ele.className = "quantitiesTd"
        id_ele.innerHTML = quantity['id']
        row.appendChild(id_ele)

        rank_agg_ele = document.createElement('td')
        rank_agg_ele.className = "quantitiesTd"
        rank_agg_ele.innerHTML = quantity['rank_agg']
        row.appendChild(rank_agg_ele)

        # append the row to the body of the table
        quantitiesTable.children[1].appendChild(row)


    # create plot group
    plot_button = document.getElementById("plotButton" + str(id))
    plot_button.addEventListener("click", create_proxy(runPlot))
    chart_button = document.getElementById("chartsButton" + str(id))
    chart_button .addEventListener("click", create_proxy(runChart))
    # add quantites to quantity 1 dropdown
    plot_q1_select = document.getElementById("quantity1_" + str(id))
    for quantity in file_dict[id].quantities:
        item = document.createElement("option")
        item.innerHTML = quantity
        item.value = quantity
        plot_q1_select.appendChild(item)

    # add quantites to quantity 2 dropdown
    plot_q2_select = document.getElementById("quantity2_" + str(id))
    for quantity in file_dict[id].quantities:
        item = document.createElement("option")
        item.innerHTML = quantity
        item.value = quantity
        plot_q2_select.appendChild(item)

    # construct plot footer
    add_line_button = document.getElementById("addLineButton" + str(id))
    add_line_button.addEventListener("click", create_proxy(addLine))
    add_line_button.param2 = 1


    # construct table header
    table_button = document.getElementById("tableButton" + str(id))
    table_button.addEventListener("click", create_proxy(addTableList))

    # add quantites to table dropdown
    table_select = document.getElementById("tableQuantitySelect" + str(id))
    for quantity in file_dict[id].quantities:
        item = document.createElement("option")
        item.innerHTML = quantity
        item.value = quantity
        table_select.appendChild(item)




    # construct table footer
    download_table_button = document.getElementById("tableDownloadButton" + str(id))
    download_table_button.addEventListener("click",
                                           create_proxy(downloadTable))
    print_table_button = document.getElementById("tablePrintButton" + str(id))
    print_table_button.addEventListener("click", create_proxy(printTable))



file_dict = {}
asyncio.ensure_future(customImports())
</py-script>

	<div style="display: flex; background-color: lightblue">
		<div style="margin:10px;padding:10px;">
			<button py-click="addFileFunc()" id="add-file" class="py-button">Add file</button>
		</div>
		<div style="margin:10px;padding:10px;font-weight:bold;">
			HTMLalizer
		</div>
	</div>

	<div id="fileList" style="display:flex;flex-direction:column">
	</div>

  </body>
</html>